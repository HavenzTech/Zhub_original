# DTO Pattern (Data Transfer Objects)

## Overview

HavenzBMS uses **DTOs (Data Transfer Objects)** to separate API contracts from domain models. This pattern prevents model validation errors, improves security, and provides clean API contracts.

## Why Use DTOs?

### Problem: Navigation Property Validation

Without DTOs, POST/PUT operations fail with validation errors:

```json
{
  "status": 400,
  "errors": {
    "Company": ["The Company field is required."]
  }
}
```

**Root Cause**: Domain entities have navigation properties (e.g., `public virtual Company Company { get; set; }`) that ASP.NET Core validates as required during model binding.

### Solution: Request DTOs

Create separate DTO classes for API requests that contain only the data fields needed, without navigation properties.

## DTO Structure

### Create Request DTO

For creating new entities (POST operations):

```csharp
using System.ComponentModel.DataAnnotations;

namespace WebApp.Models.HavenzHub
{
    public class CreateProjectRequest
    {
        [Required(ErrorMessage = "Project name is required")]
        [MaxLength(255, ErrorMessage = "Name cannot exceed 255 characters")]
        public string Name { get; set; } = string.Empty;

        [MaxLength(1000, ErrorMessage = "Description cannot exceed 1000 characters")]
        public string? Description { get; set; }

        [Required(ErrorMessage = "Status is required")]
        [RegularExpression("^(planning|active|on-hold|completed|cancelled)$",
            ErrorMessage = "Status must be: planning, active, on-hold, completed, or cancelled")]
        public string Status { get; set; } = "planning";

        [Range(0, 100, ErrorMessage = "Progress must be between 0 and 100")]
        public int Progress { get; set; } = 0;

        public DateTime? StartDate { get; set; }
        public DateTime? EndDate { get; set; }

        [Range(0, double.MaxValue, ErrorMessage = "Budget must be non-negative")]
        public decimal? BudgetAllocated { get; set; }
    }
}
```

**Key characteristics**:
- No `Id` field (generated by server)
- No `CompanyId` field (set from authorization context)
- No navigation properties (`Company`, `Documents`, etc.)
- No audit fields (`CreatedAt`, `UpdatedAt`)
- Only business data needed for creation
- Validation attributes for data integrity

### Update Request DTO

For updating existing entities (PUT operations):

```csharp
using System.ComponentModel.DataAnnotations;

namespace WebApp.Models.HavenzHub
{
    public class UpdateProjectRequest
    {
        [Required(ErrorMessage = "Project ID is required")]
        public Guid Id { get; set; }

        [Required(ErrorMessage = "Project name is required")]
        [MaxLength(255)]
        public string Name { get; set; } = string.Empty;

        [MaxLength(1000)]
        public string? Description { get; set; }

        [Required]
        [RegularExpression("^(planning|active|on-hold|completed|cancelled)$")]
        public string Status { get; set; } = "planning";

        // ... other fields same as Create DTO
    }
}
```

**Key differences from Create DTO**:
- **Includes `Id`** field for route parameter validation
- Same validation rules as Create DTO
- Still no navigation properties or audit fields

## Controller Implementation

### POST Operation (Create)

```csharp
[HttpPost]
[RequireRole("admin", "member")]
public async Task<ActionResult<Project>> Post([FromBody] CreateProjectRequest request)
{
    if (request == null)
        return BadRequest("Project request cannot be null");

    var companyId = GetCurrentCompanyId(); // From authorization

    // Map DTO to domain entity
    var project = new Project
    {
        Id = Guid.NewGuid(),
        CompanyId = companyId, // Set from auth context, not from request
        Name = request.Name,
        Description = request.Description,
        Status = request.Status,
        Priority = request.Priority,
        Progress = request.Progress,
        StartDate = request.StartDate.HasValue
            ? DateTime.SpecifyKind(request.StartDate.Value, DateTimeKind.Utc)
            : null,
        EndDate = request.EndDate.HasValue
            ? DateTime.SpecifyKind(request.EndDate.Value, DateTimeKind.Utc)
            : null,
        BudgetAllocated = request.BudgetAllocated,
        BudgetSpent = request.BudgetSpent,
        TeamLead = request.TeamLead,
        CreatedAt = DateTime.UtcNow,
        UpdatedAt = DateTime.UtcNow
    };

    var insertedProject = await _repository.AddAsync(project);

    _logger.LogInformation(
        "Project {ProjectId} created by user {UserId}",
        insertedProject.Id, GetCurrentUserId());

    return CreatedAtAction(nameof(GetById), new { id = insertedProject.Id }, insertedProject);
}
```

### PUT Operation (Update)

```csharp
[HttpPut("{id}")]
[RequireRole("admin", "member")]
public async Task<ActionResult> Put(Guid id, [FromBody] UpdateProjectRequest request)
{
    if (request == null)
        return BadRequest("Project request cannot be null");

    if (id != request.Id)
        return BadRequest("ID mismatch");

    var existingProject = await _repository.SearchByIdAsync(id);
    if (existingProject == null)
        return NotFound($"Project with ID {id} not found");

    var companyId = GetCurrentCompanyId();

    // Validate company access
    if (existingProject.CompanyId != companyId)
    {
        _logger.LogWarning(
            "User {UserId} attempted to update project {ProjectId} from different company",
            GetCurrentUserId(), id);
        return NotFound(); // 404 instead of 403 to avoid info leakage
    }

    // Map DTO to existing entity
    existingProject.Name = request.Name;
    existingProject.Description = request.Description;
    existingProject.Status = request.Status;
    existingProject.Priority = request.Priority;
    existingProject.Progress = request.Progress;
    existingProject.StartDate = request.StartDate.HasValue
        ? DateTime.SpecifyKind(request.StartDate.Value, DateTimeKind.Utc)
        : null;
    existingProject.EndDate = request.EndDate.HasValue
        ? DateTime.SpecifyKind(request.EndDate.Value, DateTimeKind.Utc)
        : null;
    existingProject.BudgetAllocated = request.BudgetAllocated;
    existingProject.BudgetSpent = request.BudgetSpent;
    existingProject.TeamLead = request.TeamLead;
    existingProject.UpdatedAt = DateTime.UtcNow;
    // CompanyId cannot be changed
    // CreatedAt is preserved from existing entity

    await _repository.UpdateAsync(existingProject);

    _logger.LogInformation(
        "Project {ProjectId} updated by user {UserId}",
        id, GetCurrentUserId());

    return NoContent(); // 204 No Content on successful update
}
```

## DateTime Handling

### PostgreSQL UTC Requirement

PostgreSQL `timestamp with time zone` columns require DateTime values with `DateTimeKind.Utc`. The system handles this globally.

### Global DateTime UTC Conversion

EF Core is configured to automatically convert all DateTime values to UTC:

**Location**: `DataAccess/BMSDataContext.cs`

```csharp
protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
{
    // Fix PostgreSQL DateTime timezone issue - all DateTime values should be UTC
    configurationBuilder.Properties<DateTime>()
        .HaveConversion<UtcDateTimeConverter>();

    configurationBuilder.Properties<DateTime?>()
        .HaveConversion<UtcNullableDateTimeConverter>();
}

public class UtcDateTimeConverter : ValueConverter<DateTime, DateTime>
{
    public UtcDateTimeConverter() : base(
        v => DateTime.SpecifyKind(v, DateTimeKind.Utc),
        v => DateTime.SpecifyKind(v, DateTimeKind.Utc))
    { }
}

public class UtcNullableDateTimeConverter : ValueConverter<DateTime?, DateTime?>
{
    public UtcNullableDateTimeConverter() : base(
        v => v.HasValue ? DateTime.SpecifyKind(v.Value, DateTimeKind.Utc) : v,
        v => v.HasValue ? DateTime.SpecifyKind(v.Value, DateTimeKind.Utc) : v)
    { }
}
```

### DateTime in DTOs

When mapping DateTime fields from DTOs to entities:

```csharp
// For nullable DateTime fields
StartDate = request.StartDate.HasValue
    ? DateTime.SpecifyKind(request.StartDate.Value, DateTimeKind.Utc)
    : null

// For required DateTime fields
CreatedAt = DateTime.UtcNow
UpdatedAt = DateTime.UtcNow
```

## Validation

### Built-in Validation Attributes

DTOs use standard validation attributes:

```csharp
[Required(ErrorMessage = "Name is required")]
[MaxLength(255, ErrorMessage = "Name cannot exceed 255 characters")]
public string Name { get; set; }

[Range(0, 100, ErrorMessage = "Progress must be between 0 and 100")]
public int Progress { get; set; }

[RegularExpression("^(planning|active|on-hold|completed)$",
    ErrorMessage = "Invalid status value")]
public string Status { get; set; }

[EmailAddress(ErrorMessage = "Invalid email format")]
public string Email { get; set; }
```

### ModelState Validation

ASP.NET Core automatically validates DTOs. If validation fails, it returns 400 Bad Request:

```json
{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "errors": {
    "Name": ["Name is required"],
    "Progress": ["Progress must be between 0 and 100"]
  }
}
```

## Security Benefits

### 1. Prevent Mass Assignment

DTOs prevent clients from setting sensitive fields:

```csharp
// Client CANNOT set these in the request:
- Id (generated by server)
- CompanyId (from authorization context)
- CreatedAt, UpdatedAt (managed by server)
- Navigation properties (prevent circular references)
```

### 2. Enforce Company Isolation

CompanyId is always set from the authorization context, not from the request:

```csharp
var companyId = GetCurrentCompanyId(); // From JWT token + X-Company-Id header

var project = new Project
{
    CompanyId = companyId, // NOT from request.CompanyId
    // ...
};
```

This prevents users from creating/updating resources in other companies.

## Creating New DTOs

### Step 1: Create the DTO Classes

Create DTOs in `WebApp/Models/HavenzHub/`:

```
WebApp/
└── Models/
    └── HavenzHub/
        ├── CreateProjectRequest.cs
        ├── UpdateProjectRequest.cs
        ├── CreateDepartmentRequest.cs
        └── UpdateDepartmentRequest.cs
```

### Step 2: Update Controller

1. Add using statement:
```csharp
using WebApp.Models.HavenzHub;
```

2. Change POST method signature:
```csharp
// Before
public async Task<ActionResult<Project>> Post([FromBody] Project project)

// After
public async Task<ActionResult<Project>> Post([FromBody] CreateProjectRequest request)
```

3. Map DTO to entity:
```csharp
var project = new Project
{
    Id = Guid.NewGuid(),
    CompanyId = GetCurrentCompanyId(),
    Name = request.Name,
    // ... map all fields
    CreatedAt = DateTime.UtcNow,
    UpdatedAt = DateTime.UtcNow
};
```

### Step 3: Update PUT method similarly

```csharp
public async Task<ActionResult> Put(Guid id, [FromBody] UpdateProjectRequest request)
{
    // Validate ID match
    if (id != request.Id)
        return BadRequest("ID mismatch");

    // Load existing entity
    var existing = await _repository.SearchByIdAsync(id);

    // Map DTO fields to entity
    existing.Name = request.Name;
    // ...
    existing.UpdatedAt = DateTime.UtcNow;

    await _repository.UpdateAsync(existing);
    return NoContent();
}
```

## Testing

### Example Request (POST)

```bash
curl -X POST http://localhost:5087/api/havenzhub/project \
  -H "Authorization: Bearer <token>" \
  -H "X-Company-Id: <company-id>" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "New Project",
    "description": "Project description",
    "status": "planning",
    "priority": "high",
    "progress": 0,
    "startDate": "2025-01-01T00:00:00Z",
    "budgetAllocated": 100000.00
  }'
```

**Expected Response**: 201 Created

```json
{
  "id": "guid-generated-by-server",
  "companyId": "guid-from-auth-context",
  "name": "New Project",
  "description": "Project description",
  "status": "planning",
  "priority": "high",
  "progress": 0,
  "startDate": "2025-01-01T00:00:00Z",
  "budgetAllocated": 100000.00,
  "createdAt": "2025-10-30T02:36:40Z",
  "updatedAt": "2025-10-30T02:36:40Z"
}
```

### Example Request (PUT)

```bash
curl -X PUT http://localhost:5087/api/havenzhub/project/<project-id> \
  -H "Authorization: Bearer <token>" \
  -H "X-Company-Id: <company-id>" \
  -H "Content-Type: application/json" \
  -d '{
    "id": "<project-id>",
    "name": "Updated Project Name",
    "description": "Updated description",
    "status": "active",
    "priority": "high",
    "progress": 50,
    "startDate": "2025-01-01T00:00:00Z",
    "budgetAllocated": 150000.00
  }'
```

**Expected Response**: 204 No Content

## Common Pitfalls

### 1. Forgetting to Map CompanyId

❌ **Wrong**:
```csharp
var project = new Project
{
    Name = request.Name,
    // Missing: CompanyId = GetCurrentCompanyId()
};
```

✅ **Correct**:
```csharp
var project = new Project
{
    CompanyId = GetCurrentCompanyId(), // REQUIRED
    Name = request.Name,
};
```

### 2. Not Validating ID Match in PUT

❌ **Wrong**:
```csharp
public async Task<ActionResult> Put(Guid id, [FromBody] UpdateProjectRequest request)
{
    var existing = await _repository.SearchByIdAsync(id);
    // Missing: if (id != request.Id) return BadRequest();
}
```

✅ **Correct**:
```csharp
public async Task<ActionResult> Put(Guid id, [FromBody] UpdateProjectRequest request)
{
    if (id != request.Id)
        return BadRequest("ID mismatch");

    var existing = await _repository.SearchByIdAsync(id);
}
```

### 3. Forgetting DateTime UTC Conversion

❌ **Wrong**:
```csharp
StartDate = request.StartDate
```

✅ **Correct**:
```csharp
StartDate = request.StartDate.HasValue
    ? DateTime.SpecifyKind(request.StartDate.Value, DateTimeKind.Utc)
    : null
```

## File Locations

- **DTOs**: `WebApp/Models/HavenzHub/`
- **Controllers**: `WebApp/Controllers/HavenzHub/`
- **DateTime Converters**: `DataAccess/BMSDataContext.cs` (lines 160-187)

## See Also

- [Authorization](./AUTHORIZATION.md) - Role-based access control
- [Testing Guide](./TESTING_GUIDE.md) - Testing POST/PUT operations
